/* Scripted SPM Event Forwarder - beanshell script*/
/* Author: Craig Gallen */
/* Version : 1.0 */


import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.HashMap;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.opennms.netmgt.events.api.EventIpcManagerFactory;
import org.opennms.netmgt.events.api.model.IEvent;
import org.opennms.netmgt.model.OnmsNode;
import org.opennms.netmgt.model.events.EventBuilder;
import org.opennms.netmgt.xml.event.AlarmData;
import org.opennms.netmgt.xml.event.Event;
import org.opennms.netmgt.xml.event.Logmsg;

urlCredential(String url, String username, String password, String query) {
    public String getUrl() {
        return url;
    }
    public String getUsername() {
        return username;
    }
    public String getPassword() {
        return password;
    }
    
    public String getQuery() {
        return query;
    }

    /* returns this beanshell declaration so that its methods can be invoked */
    return this;
}

scriptedEventSPMForwarder() {

    /* Standard OpenNMS BSM events */
    final String BSM_SERVICE_PROBLEM_UEI = "uei.opennms.org/bsm/serviceProblem";
    final String BSM_SERVICE_OPERATIONAL_STATUS_CHANGED_UEI = "uei.opennms.org/bsm/serviceOperationalStatusChanged";
    final String BSM_SERVICE_PROBLEM_RESOLVED_UEI = "uei.opennms.org/bsm/serviceProblemResolved";

    /* New OpenNMS Service Problem Reply Event */
    final String SERVICE_PROBLEM_REPLY_UEI = "uei.opennms.org/tmf656spm/serviceProblemReply";

    /* New OpenNMS Service Problem Events */
    final String SERVICE_PROBLEM_UEI = "uei.opennms.org/tmf656spm/serviceProblem";
    final String SERVICE_PROBLEM_ATTRIBUTE_VALUE_CHANGE_UEI = "uei.opennms.org/tmf656spm/serviceProblemAttributeValueChange";
    final String SERVICE_PROBLEM_INFORMATION_REQUIRED_UEI = "uei.opennms.org/tmf656spm/serviceProblemInformationRequired";
    final String SERVICE_PROBLEM_STATE_CHANGE_UEI = "uei.opennms.org/tmf656spm/serviceProblemStateChange";
    final String SERVICE_PROBLEM_CLOSED_CANCELLED_OR_DELETED_UEI ="uei.opennms.org/tmf656spm/serviceProblemClosedCancelledOrDeleted";

    /* TMF SPM Service Problem event types */
    final String SERVICE_PROBLEM_CREATE_NOTIFICATION = "ServiceProblemCreateNotification";
    final String SERVICE_PROBLEM_ATTRIBUTE_VALUE_CHANGE_NOTIFICATION = "ServiceProblemAttributeValueChangeNotification";
    final String SERVICE_PROBLEM_INFORMATION_REQUIRED_NOTIFICATION = "ServiceProblemInformationRequiredNotification";
    final String SERVICE_PROBLEM_STATE_CHANGE_NOTIFICATION = "ServiceProblemStateChangeNotification";

    m_scriptedClient = null;
    
    m_urlCredentials = null;
    
    m_notificationCredentials = null;
    
    private String m_thisOriginatingSystem="opennms-notset";

    /* URL, Registered Listener */
    m_registered_listeners = Collections.synchronizedMap(new HashMap());

    m_scheduledExecutorService = null;

    public void setUrlCredentials(List urlCredentials) {
        if (urlCredentials == null || urlCredentials.size() == 0) {
            log.error("urlCredentials is null or empty. Cannot send service problem");
            return;
        }
        for(urlCredential : urlCredentials) {
            String url = urlCredential.getUrl();
            try {
                URL u = new URL(url);
            } catch (MalformedURLException e) {
                log.error("UrlCredential[] urlCredentials malformed url="+url);
                return;
            }
        }
        m_urlCredentials = urlCredentials;
    }

    public void setThisOriginatingSystem(String thisOriginatingSystem) {
        this.m_thisOriginatingSystem = thisOriginatingSystem;
    }

    public void setScriptedClient(scriptedClient) {
        log.debug("scriptedEventSPMForwarder set scriptedClient "+ m_scriptedClient);
        m_scriptedClient = scriptedClient;
    }
    
    public JSONObject createMinimalServiceProblem(String originatingSystem, String category, String priority,
            String description, String reason, String correlationId, String[] affectedServices) {

        JSONObject spm = new JSONObject();
        if (originatingSystem != null)
            spm.put("originatingSystem", originatingSystem);
        if (category != null)
            spm.put("category", category);
        if (priority != null)
            spm.put("priority", priority);
        if (description != null)
            spm.put("description", description);
        if (reason != null)
            spm.put("reason", reason);
        if (correlationId != null)
            spm.put("correlationId", correlationId);

        if (affectedServices!=null){
            JSONArray affectedService = new JSONArray();
            for (String service : affectedServices) {
                JSONObject jservice = new JSONObject();
                jservice.put("id",service);
                jservice.put("href",null);
                affectedService.add(jservice);
            }
            spm.put("affectedService", affectedService);
        }
        return spm;
        
    }

    public Event onmsEventFromServiceProblem(String uei, JSONObject serviceProblem) {

        String id = (String) serviceProblem.get("id");
        String correlationId = (String) serviceProblem.get("correlationId");
        String href = (String) serviceProblem.get("href");
        String source = "spm-interface";
        String reason = (String) serviceProblem.get("reason");
        String originatingSystem = (String) serviceProblem.get("originatingSystem");
        String status = (String) serviceProblem.get("status");
        String priority = ( serviceProblem.get("priority")==null )? null : serviceProblem.get("priority").toString();
        String statusChangeReason = ( serviceProblem.get("statusChangeReason")==null )? null : serviceProblem.get("statusChangeReason").toString();

        EventBuilder eventBuilder = new EventBuilder(uei, source);
        
        JSONArray affectedService = (JSONArray) serviceProblem.get("affectedService");
        if(affectedService!=null) {
            String spmAffectedServicesJson = affectedService.toString();
            StringBuilder spmAffectedServicesHtml = new StringBuilder();
            for (Object svc :affectedService) {
                JSONObject jservice = (JSONObject) svc;
                String svcid = (String) jservice.get("id");
                String svchref = (String) jservice.get("href");
                spmAffectedServicesHtml.append("<a href=\""+svchref+"\">"+svcid+ "</a> ");
            }
            
            /* this will add a json version of affected services to the event */
            eventBuilder.addParam("spmAffectedServicesJson", spmAffectedServicesJson);
            
            /* this will add an html version of affected services to the event */
            eventBuilder.addParam("spmAffectedServicesHtml", spmAffectedServicesHtml.toString());

        }

        eventBuilder.setSeverity("Warning");

        /* this will add the initial correlation id to the event */
        eventBuilder.addParam("spmCorrelationId", correlationId);
        /* this will add the service problem id to the event */
        eventBuilder.addParam("spmID", id);
        /* this will add the service problem href to the event */
        eventBuilder.addParam("spmHREF", href);
        /* this will add the service problem reason to the event */
        eventBuilder.addParam("spmReason", reason);
        /* this will add the service problem originatingSystem to the event */
        eventBuilder.addParam("spmOriginatingSystem", originatingSystem);
        /* this will add the service problem status to the event */
        eventBuilder.addParam("spmStatus", status);
        /* this will add the service problem status change reason to the event */
        eventBuilder.addParam("spmStatusChangeReason", statusChangeReason);
        /* this will add the service problem priority to the event */
        eventBuilder.addParam("spmPriority", priority);

        Event event = eventBuilder.getEvent();
        
        log.debug("onmsEventFromServiceProblem id:"+id
                + " correlationId:"+correlationId
                + " href:"+href
                + " source:"+source
                + " reason:"+reason
                + " originatingSystem:"+originatingSystem
                + " affectedService:"+affectedService
                + " TO EVENT:"+event);
        
        return event;
    }

    public void handleEvent(IEvent ievent, OnmsNode node) {
        if (BSM_SERVICE_PROBLEM_UEI.equals(ievent.getUei())) {
            log.debug("handleEvent script received SERVICE_PROBLEM event:" + ievent + " node:"+node);
            updateServiceProblem(ievent);
            
        } else if (BSM_SERVICE_OPERATIONAL_STATUS_CHANGED_UEI.equals(ievent.getUei())) {
            log.debug("handleEvent script received SERVICE_OPERATIONAL_STATUS_CHANGED event:" + ievent + " node:"+node);
            
        } else if (BSM_SERVICE_PROBLEM_RESOLVED_UEI.equals(ievent.getUei())) {
            log.debug("handleEvent script received SERVICE_PROBLEM_RESOLVED event:" + ievent + " node:"+node);
        } 

    }

    public void updateServiceProblem(IEvent ievent) {

        try {
            log.debug("updateServiceProblem script received immutable event:" + ievent);
            
            Event event = Event.copyFrom(ievent);
            Integer eventId = event.getDbid();
            AlarmData alarmData = (AlarmData) event.getAlarmData();
            String reductionKey = (alarmData==null) ? null : alarmData.getReductionKey();
            String description = event.getDescr();
            String severity = event.getSeverity();
            Logmsg logmsg = event.getLogmsg();
            String logmsgStr=  (logmsg == null) ? null : logmsg.getContent();
            String uei = event.getUei();
            String businessServiceName = (event.getParm("businessServiceName") == null) ? "Undefined" : event.getParm("businessServiceName").getValue().getContent();
            String businessServiceId = (event.getParm("businessServiceId") == null) ? null : event.getParm("businessServiceId").getValue().getContent();
            String rootCause = (event.getParm("rootCause") == null) ? null : event.getParm("rootCause").getValue().getContent();
            
            /* may be in events if created by an incoming message */
            String spmHREF = (event.getParm("spmHREF") == null) ? null : event.getParm("spmHREF").getValue().getContent();
            String spmID = (event.getParm("spmID") == null) ? null : event.getParm("spmID").getValue().getContent();
            String spmOriginatingSystem = (event.getParm("spmOriginatingSystem") == null) ? null : event.getParm("spmOriginatingSystem").getValue().getContent();
            String spmStatus = (event.getParm("spmStatus") == null) ? null : event.getParm("spmStatus").getValue().getContent();
            String spmPriority = (event.getParm("spmPriority") == null) ? null : event.getParm("spmPriority").getValue().getContent();

            /* only create new service problem if href not present */
            if (spmHREF == null) {
                log.debug("updateServiceProblem event has no spmHREF param - creating new service problem");
                
                String originatingSystem = m_thisOriginatingSystem;
                String category = " equipment";
                String priority = "1";
                String reason = logmsgStr;
                String correlationId = reductionKey;
                String[] affectedServices = { businessServiceName };

                /* create new service problem for each url */
                if (m_urlCredentials.size() == 0) {
                    log.warn("no baseUrls set. Cannot send service problem.");
                }

                /* send message to all registered spm servers */
                for(urlCredential : m_urlCredentials) {
                    String baseUrl = urlCredential.getUrl();
                    String username = urlCredential.getUsername();
                    String password = urlCredential.getPassword();

                    try {

                        serviceProblem = createMinimalServiceProblem(originatingSystem, category, priority,
                                description, reason, correlationId, affectedServices);
                        log.debug("updateServiceProblem sending service problem : " + serviceProblem.toString());
                        String url = baseUrl + "/tmf-api/serviceProblemManagement/v3/serviceProblem";

                        /* post http request */
                        m_scriptedClient.postRequest(url, serviceProblem.toString(), username, password);

                    } catch (Exception e2) {
                        log.error("problem posting new service problem ", e2);
                    }

                }
            } else {
                log.debug("updateServiceProblem not creating new service problem as event has spmHREF=" + spmHREF);
            }

        } catch (Exception e) {
            log.debug("problem creating service problem",e);
        }

    }


    public synchronized void handleIncomingMessage(JSONObject message) {
        
        log.debug("handleIncomingMessage called,  message="+message);
        
        String messageSource = (String) message.get("messageSource");
        String requestMethod = (String) message.get("requestMethod");
        String requestHost = (String) message.get("requestHost");
        String requestPath = (String) message.get("requestPath");
        String requestRawUrl = (String) message.get("requestRawUrl");
        String status = (message.get("status")==null) ? null : message.get("status").toString();
        JSONObject jsonobject = (JSONObject) message.get("jsonobject");
        JSONArray jsonarray = (JSONArray) message.get("jsonarray");

        /* check if message comes as reply from a push message from asyncClyent */
        if ("asyncClient".equals(messageSource)) {

            /* possible spm sent messages */
            /* POST /tmf-api/serviceProblemManagement/v3/serviceProblem */
            /* PATCH /tmf-api/serviceProblemManagement/v3/serviceProblem/2 */
            /* DELETE /tmf-api/serviceProblemManagement/v3/serviceProblem/2 */

            if ("200".equals(status) || "201".equals(status) || "204".equals(status)) {
                /* find out what message replied to */

                /* check for reply to register for events */
                if (requestPath != null && requestPath.contains("/tmf-api/serviceProblemManagement/v3/hub")
                        && "POST".equals(requestMethod) && jsonobject != null) {
                    
                    log.debug("successfully registered for messages: " + requestPath + " reply:" + jsonobject.toString() + " requestRawUrl="+requestRawUrl);
                    String id = (String) jsonobject.get("id");
                    String url = requestRawUrl.substring(0,
                            requestRawUrl.indexOf("/tmf-api/serviceProblemManagement/v3/hub"));
                    log.debug("registering listener for : url="+ url + " id" + id);
                    m_registered_listeners.put(url, id);
                }

                /* check for reply to POST /tmf-api/serviceProblemManagement/v3/serviceProblem */
                else if (requestPath != null && requestPath.contains("/tmf-api/serviceProblemManagement/v3/serviceProblem")
                        && "POST".equals(requestMethod) && jsonobject != null) {

                    String uei = SERVICE_PROBLEM_REPLY_UEI;
                    Event event = onmsEventFromServiceProblem(uei, jsonobject);
                    log.debug("Persisting event to OpenNMS:" + event.toString());

                    try {
                        EventIpcManagerFactory.getIpcManager().sendNow(event);
                        log.debug("sent SERVICE_PROBLEM_REPLY event through ipcManager");
                    } catch (Throwable t) {
                        log.debug("problem sending event to OpenNMS:", t);
                    }

                } else {
                    /* just log reply from any other method or request */
                    log.debug("Unused reply from SPM interface: " + message.toString());
                }

            } else {
                /* create event for error reply */
                log.debug("Error Reply from SPM interface: " + message.toString());
            }

            /* check if message comes as input from httpServer */
        } else if ("httpServer".equals(messageSource)) {

            log.debug("Http server received message: " + message.toString());
            /* Note removing object declaration for beanshell */
            spmEventType = null;
            spmServiceProblem = null;
            spmServiceProblemId = null;
            spmOriginatingSystem = null;
            spmStatus = null;
            spmPriority = null;
            if (jsonobject != null) {
                spmEventType = (String) jsonobject.get("eventType");
                JSONObject spmEvent = (JSONObject) jsonobject.get("event");
                spmServiceProblem = (spmEvent == null) ? null : (JSONObject) spmEvent.get("serviceProblem");
                spmServiceProblemId = (spmServiceProblem == null) ? null : (String) spmServiceProblem.get("id");
                spmOriginatingSystem = (spmServiceProblem == null) ? null : (String) spmServiceProblem.get("originatingSystem");
                spmStatus = (spmServiceProblem == null) ? null : (String) spmServiceProblem.get("status");
                spmPriority = (spmServiceProblem == null) ? null : (Long) spmServiceProblem.get("priority");
            }
            if (spmEventType == null || spmServiceProblem == null || spmServiceProblemId == null) {
                log.debug("cannot recognise message as SPM event."
                        + " spmEventType: "+spmEventType
                        + " spmServiceProblemId: "+spmServiceProblemId
                        + " spmServiceProblem: "+spmServiceProblem
                        + " Message: " + message.toString());
            } else {
                String uei = null;
                Event event = null;
                
                switch (spmEventType) {
                /* TMF SPM Service Problem event types */
                case SERVICE_PROBLEM_CREATE_NOTIFICATION :
                    if(m_thisOriginatingSystem.equals(spmOriginatingSystem)){
                        log.debug("not handling spm create notification which carries a create from our own originatingSystem="+spmOriginatingSystem);
                        break;
                    }
                    uei = SERVICE_PROBLEM_UEI;
                    event = onmsEventFromServiceProblem(uei, spmServiceProblem);
                    log.debug("Persisting event to OpenNMS:" + event.toString());
                    try {
                        EventIpcManagerFactory.getIpcManager().sendNow(event);
                        log.debug("sent SERVICE_PROBLEM_CREATE_NOTIFICATION event through ipcManager");
                    } catch (Throwable t) {
                        log.debug("problem sending event to OpenNMS:", t);
                    }
                    break;
                case SERVICE_PROBLEM_STATE_CHANGE_NOTIFICATION :
                	// check if state is now Closed or Cancelled
                	if("Closed".equals(spmStatus) || "Cancelled".equals(spmStatus) ) {
                		uei = SERVICE_PROBLEM_CLOSED_CANCELLED_OR_DELETED_UEI;
                	} else {
                		uei = SERVICE_PROBLEM_STATE_CHANGE_UEI;
                	}

                    event = onmsEventFromServiceProblem(uei, spmServiceProblem);
                    log.debug("Persisting event to OpenNMS:" + event.toString());
                    try {
                        EventIpcManagerFactory.getIpcManager().sendNow(event);
                        log.debug("received SERVICE_PROBLEM_STATE_CHANGE_NOTIFICATION sent "+uei+" event through ipcManager");
                    } catch (Throwable t) {
                        log.debug("problem sending event to OpenNMS:", t);
                    }
                    break;
                case SERVICE_PROBLEM_ATTRIBUTE_VALUE_CHANGE_NOTIFICATION :
                	// check if state is now Closed or Cancelled
                	if("Closed".equals(spmStatus) || "Cancelled".equals(spmStatus) ) {
                		uei = SERVICE_PROBLEM_CLOSED_CANCELLED_OR_DELETED_UEI;
                	} else {
                		uei = SERVICE_PROBLEM_ATTRIBUTE_VALUE_CHANGE_UEI;
                	}
                	
                    event = onmsEventFromServiceProblem(uei, spmServiceProblem);
                    log.debug("Persisting event to OpenNMS:" + event.toString());
                    try {
                        EventIpcManagerFactory.getIpcManager().sendNow(event);
                        log.debug("received SERVICE_PROBLEM_ATTRIBUTE_VALUE_CHANGE_NOTIFICATION sent "+uei+" event through ipcManager");
                    } catch (Throwable t) {
                        log.debug("problem sending event to OpenNMS:", t);
                    }
                    break;
                case SERVICE_PROBLEM_INFORMATION_REQUIRED_NOTIFICATION :
                    uei = SERVICE_PROBLEM_INFORMATION_REQUIRED_UEI;
                    event = onmsEventFromServiceProblem(uei, spmServiceProblem);
                    log.debug("Persisting event to OpenNMS:" + event.toString());
                    try {
                        EventIpcManagerFactory.getIpcManager().sendNow(event);
                        log.debug("sent SERVICE_PROBLEM_INFORMATION_REQUIRED_NOTIFICATION event through ipcManager");
                    } catch (Throwable t) {
                        log.debug("problem sending event to OpenNMS:", t);
                    }
                    break;
                default:
                    log.debug("unknown SPM event type. spmEventType: " + spmEventType);
                }
            }

        } else {
            /* unknown message source */
            log.debug("message received from unknown internal source:" + messageSource + " message: "
                    + message.toString());
        }

    }
    
    public void startRegisterNotifications(notificationCredentials, callbackCredential) {
        log.debug("starting notification registration process");
        if (notificationCredentials == null || notificationCredentials.size() == 0 || callbackCredential == null) {
            log.error("UrlCredential[] notificationCredentials is null or empty. Cannot register for notifications");
            return;
        }
        if (callbackCredential == null || callbackCredential.getUrl() == null) {
            log.error("callback credential is null or callback url is null. Cannot register for notifications");
            return;
        }
        try {
            URL u = new URL(callbackCredential.getUrl());
        } catch (MalformedURLException e) {
            log.error("callbackCredential.getUrl() malformed url=" + callbackCredential.getUrl());
            return;
        }
        for (notificationCredential : notificationCredentials) {
            String url = notificationCredential.getUrl();
            try {
                URL u = new URL(url);
            } catch (MalformedURLException e) {
                log.error("notificationCredential[] notificationCredential malformed url=" + url);
                return;
            }
        }
        
        m_notificationCredentials = notificationCredentials;

        /* run as daemon so that we definitely exit */
        ThreadFactory threadFactory = new ThreadFactory() {
            public Thread newThread(Runnable r) {
                Thread t = Executors.defaultThreadFactory().newThread(r);
                t.setDaemon(true);
                return t;
            }
        };
        
        m_scheduledExecutorService = Executors.newScheduledThreadPool(1, threadFactory);
                
        /* using runnable because of beanshell */
        Runnable ttask = new Runnable() {

            public void run() {
                log.debug("credentialTimer trying to register for notifications m_registered_listeners.size()="+m_registered_listeners.size()
                    +" m_notificationCredentials.size()="+m_notificationCredentials.size());
                if(m_registered_listeners.size()>=m_notificationCredentials.size() ) {
                    log.debug("all notifications registered. Ending timer");
                    m_scheduledExecutorService.shutdown();
                    return;
                } else try {
                    log.debug("still unregisterd credentials. Trying registration");
                    for (urlCredential : m_notificationCredentials) {
                        String url = urlCredential.getUrl();
                        String query = urlCredential.getQuery();
                        if (!m_registered_listeners.containsKey(url)) {
                            log.debug("trying to register for notification: server url="+url+ " callbackUrl="+ callbackCredential.getUrl()
                                    + " query="+query);
                            try{
                                registerForNotifications(urlCredential, callbackCredential, query);
                            } catch (Exception ex){
                                log.error("problem registering for notifications",ex);
                            }
                         }
                    }
                } catch (Exception ex) {
                    log.error("problem registering for notifications", ex);
                }
            }
        };

        /* run every 30 seconds until all urls registered */
        m_scheduledExecutorService.scheduleAtFixedRate(ttask, 0, 30, TimeUnit.SECONDS); 

    }

    public void stopRegisterNotifications() {
        log.debug("stopping notification registration process for "+m_notificationCredentials.size()+" credentials"); 
        if (m_scheduledExecutorService != null)
            m_scheduledExecutorService.shutdownNow();
        try {
            for (urlCredential : m_notificationCredentials) {
                url = urlCredential.getUrl();
                id = m_registered_listeners.get(url);
                if (id != null) {
                    log.debug("unregistering for notification: server url="+url+ " registration id="+id);
                    try {
                        unRegisterForNotifications(urlCredential, id);
                    } catch (Exception ex){
                        log.error("problem un-registering for notifications",ex);
                    }
                }
            }
            m_registered_listeners.clear();
        } catch (Exception ex) {
            log.error("problem un-registering for notifications", ex);
        }
    }

    private void unRegisterForNotifications(urlCredential, String id) {
        m_scriptedClient.deleteRequest(urlCredential.getUrl() + "/tmf-api/serviceProblemManagement/v3/hub"+"/" + id, urlCredential.getUsername(),
                urlCredential.getPassword());
    }

    private void registerForNotifications(urlCredential, callback, String query) {
        JSONObject hubRequest = new JSONObject();
        hubRequest.put("callback", callback.getUrl());
        hubRequest.put("query", query);
        m_scriptedClient.postRequest(urlCredential.getUrl() + "/tmf-api/serviceProblemManagement/v3/hub", hubRequest.toString(),
                urlCredential.getUsername(), urlCredential.getPassword());
    }
        
    /* returns this beanshell declaration so that its methods can be invoked */
    return this;

}
